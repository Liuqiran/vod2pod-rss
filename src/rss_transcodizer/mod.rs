use std::collections::BTreeMap;
use std::fmt::Display;
use std::ops::Deref;
use std::rc::Rc;
use std::time::Duration;

#[allow(unused_imports)]
use cached::proc_macro::io_cached;
#[allow(unused_imports)]
use cached::AsyncRedisCache;
use chrono::DateTime;
use eyre::eyre;
use feed_rs::model::{Entry, MediaObject};
use feed_rs::parser;
use futures::stream::FuturesUnordered;
use futures::StreamExt;
use log::{debug, warn};
use reqwest::Url;
use rss::extension::itunes::ITunesChannelExtensionBuilder;
use rss::{extension::itunes::ITunesItemExtensionBuilder, Enclosure, Item, ItemBuilder};
use rss::{Guid, GuidBuilder};

use std::str;

use crate::configs::{conf, AudioCodec, Conf, ConfName};
use crate::provider;

/// This module takes in an URL to an rss/atom feed, fetches it and converts it to a
/// RSS feed with it's links rewritten to call the transcoder urls of the app,
/// it will also edit and insert fields like description and thumbnails if possible
pub struct RssTranscodizer {
    feed_url: Url,
    transcode_service_url: Url,
    should_transcode: bool,
    raw_rss: String,
}

impl RssTranscodizer {
    pub fn new(
        url: Url,
        transcode_service_url: Url,
        should_transcode: bool,
        raw_rss: String,
    ) -> Self {
        Self {
            feed_url: url,
            transcode_service_url,
            should_transcode,
            raw_rss,
        }
    }

    pub async fn transcodize(&self) -> eyre::Result<String> {
        let feed = match parser::parse(&self.raw_rss.as_bytes()[..]) {
            Ok(x) => {
                debug!("parsed feed");
                x
            }
            Err(e) => {
                return Err(eyre!("could not parse rss, reason: {e}"));
            }
        };

        let mut namespaces = BTreeMap::new();
        namespaces.insert(
            "rss".to_string(),
            "http://www.itunes.com/dtds/podcast-1.0.dtd".to_string(),
        );
        namespaces.insert(
            "itunes".to_string(),
            "http://www.itunes.com/dtds/podcast-1.0.dtd".to_string(),
        );
        let mut feed_builder = rss::ChannelBuilder::default();
        feed_builder.namespaces(namespaces);
        if let Some(x) = feed.title {
            debug!("Title found: {}", x.content);
            feed_builder.title(x.content);
        }

        if let Some(x) = feed.description {
            debug!("Description found: {}", x.content);
            feed_builder.description(x.content);
        }

        if let Some(x) = feed.logo {
            debug!("image found, logo branch: x={:?}", x);
            let mut img_buider = rss::ImageBuilder::default();
            img_buider.url(x.uri);
            img_buider.link(x.title.unwrap_or_default());
            img_buider.description(Some(x.description.unwrap_or_default()));
            feed_builder.image(Some(img_buider.build()));
        } else {
            if let Some(x) = feed.icon {
                debug!("image found, icon branch: x={:?}", x);
                let mut img_buider = rss::ImageBuilder::default();
                img_buider.url(x.uri);
                img_buider.link(x.title.unwrap_or_default());
                img_buider.description(Some(x.description.unwrap_or_default()));
                feed_builder.image(Some(img_buider.build()));
            }
        }

        feed_builder.generator(Some("generated by vod2pod-rss".to_string()));

        let futures = FuturesUnordered::new();
        let service_url_rc = Rc::new(self.transcode_service_url.to_owned());
        let feed_url_rc = Rc::new(self.feed_url.to_owned());
        for entry in feed.entries.iter() {
            let ser_url = service_url_rc.clone();
            let f_url = feed_url_rc.clone();
            futures.push(async move {
                convert_item(ConvertItemsParams {
                    item: entry.to_owned(),
                    transcode_service_url: ser_url,
                    should_transcode: self.should_transcode,
                    feed_url: f_url,
                })
                .await
            });
        }

        let item_futures: Vec<_> = futures.collect().await;
        let mut feed_items: Vec<_> = item_futures
            .iter()
            .filter_map(|x| {
                if !x.is_none() {
                    Some(x.to_owned().unwrap())
                } else {
                    None
                }
            })
            .collect();
        feed_items.sort_by(|a, b| {
            DateTime::parse_from_rfc2822(b.pub_date().unwrap_or_default())
                .unwrap_or_default()
                .cmp(
                    &DateTime::parse_from_rfc2822(&a.pub_date().unwrap_or_default())
                        .unwrap_or_default(),
                )
        });
        feed_builder.items(feed_items);

        let mut itunes_section = ITunesChannelExtensionBuilder::default();
        itunes_section.block(Some("yes".to_string())); //this tells podcast players to not index the podcast in their search engines
        feed_builder.itunes_ext(Some(itunes_section.build()));

        Ok(feed_builder.build().to_string())
    }
}

#[derive(Clone, Hash)]
struct TranscodeParams {
    transcode_service_url_str: String,
    feed_url: Url,
    should_transcode: bool,
}

impl Display for TranscodeParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}_{}", &self.transcode_service_url_str, &self.feed_url)
    }
}

struct ConvertItemsParams {
    item: Entry,
    transcode_service_url: Rc<Url>,
    should_transcode: bool,
    feed_url: Rc<Url>,
}

async fn convert_item(params: ConvertItemsParams) -> Option<Item> {
    let item = params.item;
    let transcode_service_url = params.transcode_service_url;
    let provider = provider::from_v2(&params.feed_url);

    let mut item_builder = ItemBuilder::default();
    let mut itunes_builder = ITunesItemExtensionBuilder::default();

    if let Some(x) = &item.title {
        debug!("item title: {}", x.content);
        item_builder.title(Some(x.content.clone()));
    }

    let media_links = item
        .media
        .iter()
        .map(|f| f.to_owned().content)
        .flatten()
        .filter_map(|x| x.url);

    let item_links = item
        .links
        .iter()
        .map(|x| x.to_owned().href)
        .filter_map(|a| Url::parse(a.as_str()).ok());

    let content_links = item
        .content
        .iter()
        .filter_map(|x| x.to_owned().src)
        .map(|x| x.href)
        .filter_map(|a| Url::parse(a.as_str()).ok());

    let mut all_items_iter = media_links.chain(item_links).chain(content_links);

    let selected_url = all_items_iter.find(|x| {
        let provider_regexes = provider.media_url_regexes();
        return provider_regexes.iter().any(|y| y.is_match(&x.to_string()));
    });

    let Some(media_url) = selected_url else {
        log::warn!(
            "no media_url found out of:\n{:?}",
            all_items_iter
                .clone()
                .map(|x| x.to_string())
                .collect::<Vec<String>>()
                .join("\n")
        );
        log::warn!(
            "links analyzed:\n{:?}",
            all_items_iter
                .map(|x| x.to_string())
                .collect::<Vec<String>>()
                .join("\n")
        );
        log::warn!(
            "regex used:\n{:?}",
            provider
                .media_url_regexes()
                .iter()
                .map(|x| x.to_string())
                .collect::<Vec<String>>()
                .join("\n")
        );
        return None;
    };

    let media_element = match item.media.first() {
        Some(x) => x,
        None => {
            warn!("no media element found");
            return None;
        }
    };

    let description = get_description(&media_element, &item, &media_url);
    item_builder.description(Some(description));

    if let Some(x) = item.published {
        debug!("Published date found: {:?}", x.to_rfc2822());
        item_builder.pub_date(Some(x.to_rfc2822()));
    }

    if let Some(x) = &media_element.thumbnails.first() {
        debug!("Thumbnail image found: {:?}", x.image.uri);
        itunes_builder.image(Some(x.image.uri.clone()));
    }

    let duration = match media_element.duration {
        Some(x) => {
            debug!("duration found: {} secs", x.as_secs());
            x
        }
        None => {
            warn!("no duration found for item");
            Duration::default()
        }
    };

    let duration_secs = duration.as_secs();
    if duration_secs == 0 {
        warn!(
            "skipping episode with 0 duration with title {}",
            &item
                .title
                .map(|t| t.content.to_string())
                .unwrap_or_default()
        );
        return None;
    }
    let duration_string = format!(
        "{:02}:{:02}:{:02}",
        duration_secs / 3600,
        (duration_secs % 3600) / 60,
        (duration_secs % 60)
    );
    itunes_builder.duration(Some(duration_string));
    let mut transcode_service_url = transcode_service_url.deref().clone();
    let bitrate: u64 = conf()
        .get(ConfName::Mp3Bitrate)
        .unwrap()
        .parse()
        .expect("MP3_BITRATE must be a number");
    let generation_uuid = uuid::Uuid::new_v4().to_string();
    let codec: AudioCodec = conf().get(ConfName::AudioCodec).unwrap().into();
    let ext = format!(".{}", codec.get_extension_str());
    transcode_service_url
        .query_pairs_mut()
        .append_pair("bitrate", bitrate.to_string().as_str())
        .append_pair("uuid", generation_uuid.as_str())
        .append_pair("duration", duration_secs.to_string().as_str())
        .append_pair("url", media_url.as_str())
        .append_pair("ext", ext.as_str()); //this should allways be last, some players refuse to play urls not ending in .mp3

    let enclosure = Enclosure {
        length: (bitrate * 1024 * duration_secs).to_string(),
        url: transcode_service_url.to_string(),
        mime_type: "audio/mpeg".to_string(),
    };

    debug!(
        "setting enclosure to: \nlength: {}, url: {}, mime_type: {}",
        enclosure.length, enclosure.url, enclosure.mime_type
    );

    let guid = generate_guid(&item.id);
    item_builder.guid(Some(guid));
    if params.should_transcode {
        item_builder.enclosure(Some(enclosure));
    }

    item_builder.itunes_ext(Some(itunes_builder.build()));
    debug!(
        "item parsing completed!\n------------------------------\n------------------------------"
    );
    Some(item_builder.build())
}

fn generate_guid(url: &str) -> Guid {
    let digest: md5::Digest = md5::compute(url);
    let md5_bytes_from_digest = digest.0;
    let uuid_for_item: uuid::Builder = uuid::Builder::from_md5_bytes(md5_bytes_from_digest);
    let uuid = uuid_for_item.as_uuid().clone();
    let mut guid_builder = GuidBuilder::default();
    guid_builder.permalink(true).value(uuid.to_string());
    guid_builder.build()
}

fn get_description(media_element: &MediaObject, item: &Entry, url: &Url) -> String {
    const FOOTER: &str = concat!(
        "<br><br>generated by vod2pod-rss ",
        env!("CARGO_PKG_VERSION"),
        " made by Mattia Di Eleuterio (<a href=\"https://github.com/madiele\">madiele</a>). Check out the <a href=\"https://github.com/madiele/vod2pod-rss\">GitHub repository</a>."
    );
    let mut description = "".to_string();

    if let Some(x) = &media_element.description {
        debug!("Description found: {:?}", x.content);
        description = x.content.clone();
    } else if let Some(x) = &item.content {
        debug!("Description found: {:?}", x);
        description = x.body.clone().unwrap_or_default();
    } else if let Some(x) = &item.summary {
        debug!("Description found: {:?}", x);
        description = x.content.to_string().clone();
    }

    let original_link = format!("<br><br><a href=\"{}\"><p>link to original</p></a>", url);
    return format!("{}{}{}", description, original_link, FOOTER);
}

#[cfg(test)]
mod test {
    use actix_web::{
        dev::ServerHandle,
        http::header::ContentType,
        rt,
        web::{self, Data},
        App, HttpResponse, HttpServer,
    };
    use rss::Channel;
    use test_log::test;

    use super::*;

    async fn validate_must_have_props(rss_transcodizer: RssTranscodizer) -> Result<(), String> {
        println!("fake server up");
        println!("transcodizing");

        let transcodized_rss = rss_transcodizer
            .transcodize()
            .await
            .expect("failed to transcodize RSS feed");

        println!("parsing feed");
        // Parse the transcodized RSS to make it easier to compare
        let transcodized_rss_parsed = Channel::read_from(transcodized_rss.as_bytes()).unwrap();
        println!("checking feed validity");

        _ = match transcodized_rss_parsed.generator() {
            None => return Err(format!("missing generator field")),
            _ => (),
        };

        if transcodized_rss_parsed.items().len() == 0 {
            return Err("no items found".to_string());
        }

        for i in transcodized_rss_parsed.items().iter() {
            let pretty_item = serde_json::to_string(&i).unwrap();

            if i.itunes_ext().is_none() {
                return Err(format!("missing itunes extensions {:?}", pretty_item));
            }

            if i.itunes_ext().unwrap().duration().is_none() {
                return Err(format!("missing duration {:?}", pretty_item));
            }

            if i.guid().is_none() {
                return Err(format!("missing guid for item {:?}", pretty_item));
            }

            if i.enclosure.is_none() {
                return Err(format!("missing enclosure for item {:?}", pretty_item));
            }

            if i.title.is_none() {
                return Err(format!("missing title for item {:?}", pretty_item));
            }

            if i.description.is_none() {
                return Err(format!("missing description for item {:?}", pretty_item));
            }
        }
        return Ok(());
    }

    async fn stop_test(handle: ServerHandle) {
        handle.stop(false).await
    }

    #[test(actix_web::test)]
    async fn rss_podcast_feed() -> Result<(), String> {
        temp_env::async_with_vars(
            [("VALID_URL_DOMAINS", Some("https://*.simplecast.com"))],
            test(),
        )
        .await;

        async fn test() {
            let handle = startup_test("podcast".to_string(), 9872).await;

            let rss_url = Url::parse("http://127.0.0.1:9872/feed.rss").unwrap();
            let raw_rss = reqwest::get(rss_url.clone())
                .await
                .expect("failed to get raw RSS")
                .text()
                .await
                .expect("failed to get RSS bytes");
            println!("testing feed {rss_url}");
            let transcode_service_url = "http://127.0.0.1:9872/transcode".parse().unwrap();
            let rss_transcodizer =
                RssTranscodizer::new(rss_url, transcode_service_url, true, raw_rss);

            let res = validate_must_have_props(rss_transcodizer).await;

            stop_test(handle).await;
            if let Err(e) = res {
                panic!("{e}");
            }
        }
        Ok(())
    }

    #[test(actix_web::test)]
    async fn rss_twitch_feed() -> Result<(), String> {
        let handle = startup_test("twitch".to_string(), 9871).await;

        let rss_url = Url::parse("http://127.0.0.1:9871/feed.rss").unwrap();
        let raw_rss = reqwest::get(rss_url.clone())
            .await
            .expect("failed to get raw RSS")
            .text()
            .await
            .expect("failed to get RSS bytes");
        println!("testing feed {rss_url}");
        let transcode_service_url = "http://127.0.0.1:9871/transcode".parse().unwrap();
        let rss_transcodizer = RssTranscodizer::new(rss_url, transcode_service_url, true, raw_rss);

        let res = validate_must_have_props(rss_transcodizer).await;

        stop_test(handle).await;

        res
    }

    #[test(actix_web::test)]
    async fn rss_youtube_feed() {
        let handle = startup_test("youtube".to_string(), 9870).await;

        let rss_url = Url::parse("http://127.0.0.1:9870/feed.rss").unwrap();
        let raw_rss = reqwest::get(rss_url.clone())
            .await
            .expect("failed to get raw RSS")
            .text()
            .await
            .expect("failed to get RSS bytes");
        println!("testing feed {rss_url}");
        let transcode_service_url = "http://127.0.0.1:9870/transcode".parse().unwrap();
        let rss_transcodizer = RssTranscodizer::new(rss_url, transcode_service_url, true, raw_rss);

        let res = validate_must_have_props(rss_transcodizer).await;

        stop_test(handle).await;

        if let Err(e) = res {
            panic!("{e}");
        }
    }

    async fn startup_test(type_test: String, port: u16) -> ServerHandle {
        let feed_type = Data::new(type_test);
        let fake_server = HttpServer::new(move || {
            App::new()
                .app_data(Data::clone(&feed_type))
                .route(
                    "/feed.rss",
                    web::get().to(|feed_type: Data<String>| async move {
                        let url = format!(
                            "./src/rss_transcodizer/sample_rss/{}.rss",
                            feed_type.to_string()
                        );
                        println!("reading rss from file: {url}");
                        let raw_rss_str = std::fs::read_to_string(url).unwrap();
                        HttpResponse::Ok()
                            .content_type(ContentType::xml())
                            .body(raw_rss_str)
                    }),
                )
                .route(
                    "/ready",
                    web::get().to(|| async move { HttpResponse::Ok() }),
                )
        })
        .bind(("127.0.0.1", port))
        .unwrap()
        .run();
        let handle = fake_server.handle();
        rt::spawn(fake_server);
        handle
    }
}

