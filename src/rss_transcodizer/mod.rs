//this module will take an existing RSS and output a new RSS with the enclosure replaced by the trascode URL
//usage example
//GET /rss?url=https://website.com/url/to/feed.rss
//media will have original url replaced by
//GET /transcode/UUID?url=https://website.com/url/to/media.mp3
//GET /transcode/UUID?url=https://website.com/url/to/media.mp4
//GET /transcode/UUID?url=https://website.com/url/to/media.m3u8 (this will require some trickery to get the correct duration)
//in the frist version those calls will use the duration field in the RSS with the constant bitrate of the transcoder to generate
//a correct byte range
//in future version they will try to get the first secs of the original to get the bitrate and original byte range

use std::time::Duration;

use eyre::eyre;
use log::{warn, debug};
use reqwest::Url;
use rss::{ Enclosure, ItemBuilder, Item, extension::itunes::ITunesItemExtensionBuilder };
use feed_rs::parser;

use std::process::Command;
use std::str;

fn get_youtube_video_duration(url: &str) -> u64 {
    debug!("getting duration for yt video: {}", url);
    let output = Command::new("yt-dlp")
        .arg("--get-duration")
        .arg(url)
        .output();

    if let Ok(x) = output {
        let duration_str = str::from_utf8(&x.stdout).unwrap().trim().to_string();
        parse_duration(&duration_str).unwrap().as_secs()
    } else {
        warn!("could not parse youtube video duration");
        0
    }

}

fn parse_duration(duration_str: &str) -> Result<Duration, String> {
    let duration_parts: Vec<&str> = duration_str.split(':').collect();

    let hours: u64 = duration_parts[0].parse().map_err(|_| "Invalid format".to_string())?;
    let minutes: u64 = duration_parts[1].parse().map_err(|_| "Invalid format".to_string())?;
    let seconds: u64 = duration_parts[2].parse().map_err(|_| "Invalid format".to_string())?;

    Ok(Duration::from_secs(hours * 3600 + minutes * 60 + seconds))
}

pub struct RssTranscodizer {
    url: String,
    transcode_service_url: Url,
}

impl RssTranscodizer {
    pub fn new(url: String, transcode_service_url: Url) -> Self {
        Self { url, transcode_service_url }
    }

    pub async fn transcodize(&self) -> eyre::Result<String> {
        let rss_body = (async { reqwest::get(&self.url).await?.bytes().await }).await?;
        let generation_uuid  = uuid::Uuid::new_v4().to_string();

        //RSS parsing
        //let mut rss = match Channel::read_from(&rss_body[..]) {
        //    Ok(x) => x,
        //    Err(e) => {
        //        return Err(eyre!("could not parse rss, reason: {e}"));
        //    }
        //};

        let feed = match parser::parse(&rss_body[..]) {
            Ok(x) => x,
            Err(e) => {
                return Err(eyre!("could not parse rss, reason: {e}"));
            }
        };

        let mut feed_builder = rss::ChannelBuilder::default();
        if let Some(x) = feed.title {
            feed_builder.title(x.content);
        }

        if let Some(x) = feed.description {
            feed_builder.description(x.content);
        }

        if let Some(x) = feed.logo {
            let mut img_buider = rss::ImageBuilder::default();
            img_buider.url(x.uri);
            img_buider.link(x.title.unwrap_or_default());
            img_buider.description(Some(x.description.unwrap_or_default()));
            feed_builder.image(Some(img_buider.build()));
        } else {
            if let Some(x) = feed.icon {
                let mut img_buider = rss::ImageBuilder::default();
                img_buider.url(x.uri);
                img_buider.link(x.title.unwrap_or_default());
                img_buider.description(Some(x.description.unwrap_or_default()));
                feed_builder.image(Some(img_buider.build()));
            }
        }

        feed_builder.generator(Some("generated by VodToPodcastRss".to_string()));

        let feed_items: Vec<Item> = feed.entries.iter().filter_map(|item| {

            let mut item_builder = ItemBuilder::default();

            if let Some(x) = &item.title {
                item_builder.title(Some(x.content.clone()));
            }

            let enclosure = match item.links.first() {
                Some(x) => x,
                None => {
                    warn!( "item has no media, skipping");
                    return None
                }
            };

            let media_url = match Url::parse(&enclosure.href) {
                Ok(x) => x,
                Err(_) => {
                    warn!("item has an invalid url");
                    return None
                }
            };

            let media_element = match item.media.first() {
                Some(x) => x,
                None => {
                    warn!("no media element found");
                    return None
                }
            };

            if let Some(x) = &media_element.description {

                item_builder.description(Some(x.content.clone()));
            }

            if let Some(x) = &media_element.thumbnails.first() {
                let mut itunes_builder = ITunesItemExtensionBuilder::default();
                itunes_builder.image(Some(x.image.uri.clone()));
                item_builder.itunes_ext(Some(itunes_builder.build()));
            }

            let duration = match media_element.duration {
                Some(x) => x,
                None => {
                    debug!("runnign regex on url: {}", media_url.as_str());
                    let youtube_regex = regex::Regex::new(r#"^(https?://)?(www\.)?(youtu\.be/|youtube\.com/)"#).unwrap();
                    if youtube_regex.is_match(media_url.as_str()) {
                        Duration::from_secs(get_youtube_video_duration(media_url.as_str()))
                    } else {
                        warn!("no duration found");
                        Duration::default()
                    }
                }
            };

            let duration_secs = duration.as_secs();

            let mut transcode_service_url = self.transcode_service_url.clone();
            let bitrate = 64; //TODO: refactor
            transcode_service_url
                .query_pairs_mut()
                .append_pair("url", media_url.as_str())
                .append_pair("bitrate", bitrate.to_string().as_str())
                .append_pair("uuid", generation_uuid.as_str())
                .append_pair("duration", duration_secs.to_string().as_str());

            let enclosure = Enclosure {
                length: (bitrate * 1024 * duration_secs).to_string(),
                url: transcode_service_url.to_string(),
                mime_type: "audio/mpeg".to_string(),
            };

            item_builder.enclosure(Some(enclosure));

            Some(item_builder.build())
        }).collect();

        feed_builder.items(feed_items);

        Ok(feed_builder.build().to_string())
    }
}



//#[cfg(test)]
//mod test {
//    use std::path::PathBuf;
//    use log::info;
//    use regex::Regex;
//    use super::*;
//
//    //AI generated
//    //TODO: check for errors
//    #[test]
//    fn test_rss_transcodizer() {
//        let rss_url = "https://example.com/rss.xml".to_string();
//        let transcode_service_url = "https://example.com/transcode".parse().unwrap();
//        let rss_transcodizer = RssTranscodizer::new(rss_url, transcode_service_url);
//
//        let mock_rss = r#"
//            <?xml version="1.0"?>
//            <rss version="2.0">
//                <channel>
//                    <title>Example RSS Feed</title>
//                    <link>https://example.com</link>
//                    <description>This is an example RSS feed</description>
//                    <item>
//                        <title>Item 1</title>
//                        <link>https://example.com/item1</link>
//                        <description>This is the first item</description>
//                        <enclosure url="https://example.com/media1.mp3" length="1024" type="audio/mpeg" />
//                        <itunes:duration>00:01:00</itunes:duration>
//                    </item>
//                    <item>
//                        <title>Item 2</title>
//                        <link>https://example.com/item2</link>
//                        <description>This is the second item</description>
//                        <enclosure url="https://example.com/media2.mp3" length="1024" type="audio/mpeg" />
//                        <itunes:duration>00:02:00</itunes:duration>
//                    </item>
//                </channel>
//            </rss>
//        "#;
//
//        let expected_rss = r#"
//            <?xml version="1.0"?>
//            <rss version="2.0">
//                <channel>
//                    <title>Example RSS Feed</title>
//                    <link>https://example.com</link>
//                    <description>This is an example RSS feed</description>
//                    <item>
//                        <title>Item 1</title>
//                        <link>https://example.com/item1</link>
//                        <description>This is the first item</description>
//                        <enclosure url="https://example.com/transcode?url=https%3A%2F%2Fexample.com%2Fmedia1.mp3&amp;bitrate=64&amp;UUID=%5Bgenerated_uuid%5D&amp;duration=60" length="640" type="audio/mpeg" />
//                        <itunes:duration>00:01:00</itunes:duration>
//                    </item>
//                    <item>
//                        <title>Item 2</title>
//                        <link>https://example.com/item2</link>
//                        <description>This is the second item</description>
//                        <enclosure url="https://example.com/transcode?url=https%3A%2F%2Fexample.com%2Fmedia2.mp3&amp;bitrate=64&amp;UUID=%5Bgenerated_uuid%5D&amp;duration=120" length="1280" type="audio/mpeg" />
//                        <itunes:duration>00:02:00</itunes:duration>
//                    </item>
//                </channel>
//            </rss>
//    "#;
//    let mock_server = warp::test::server(move || {
//        warp::path("rss.xml")
//            .map(move || mock_rss.to_string())
//    });
//
//    let transcodized_rss = rss_transcodizer
//        .transcodize()
//        .await
//        .expect("failed to transcodize RSS feed");
//
//    // Parse the transcodized RSS to make it easier to compare
//    let transcodized_rss_parsed = Channel::read_from(transcodized_rss.as_bytes()).unwrap();
//
//    // Replace the UUID in the expected RSS with the actual UUID generated by the transcodizer
//    let mut expected_rss = expected_rss.replace("%5Bgenerated_uuid%5D", &transcodized_rss_parsed.items[0].enclosure.unwrap().url.split("&UUID=").last().unwrap().split("&").next().unwrap());
//
//    // Parse the expected RSS to make it easier to compare
//    let expected_rss_parsed = Channel::read_from(expected_rss.as_bytes()).unwrap();
//
//    // Compare the transcodized RSS with the expected RSS
//    assert_eq!(transcodized_rss_parsed, expected_rss_parsed);
//    }
//}
