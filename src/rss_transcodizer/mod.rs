use std::collections::BTreeMap;
use std::fmt::Display;
use std::ops::Deref;
use std::rc::Rc;
use std::time::Duration;

#[allow(unused_imports)]
use cached::AsyncRedisCache;
#[allow(unused_imports)]
use cached::proc_macro::io_cached;
use chrono::DateTime;
use futures::stream::FuturesUnordered;
use futures::StreamExt;
use eyre::eyre;
use feed_rs::model::{Entry, MediaObject};
use log::{warn, debug, error};
use reqwest::Url;
use rss::extension::itunes::ITunesChannelExtensionBuilder;
use rss::{GuidBuilder, Guid};
use rss::{ Enclosure, ItemBuilder, Item, extension::itunes::ITunesItemExtensionBuilder };
use feed_rs::parser;

use std::str;

use crate::configs::{conf, ConfName, Conf, AudioCodec};
use crate::provider;

pub struct RssTranscodizer {
    feed_url: Url,
    transcode_service_url: Url,
    should_transcode: bool,
}


impl RssTranscodizer {
    pub fn new(url: Url, transcode_service_url: Url, should_transcode: bool) -> Self {
        Self { feed_url: url, transcode_service_url, should_transcode}
    }

    pub async fn transcodize(&self) -> eyre::Result<String> {

        cached_transcodize(TranscodeParams {
            transcode_service_url_str: self.transcode_service_url.clone().to_string(),
            feed_url: self.feed_url.to_owned(),
            should_transcode: self.should_transcode
        }).await
    }
}

#[derive(Clone, Hash)]
struct TranscodeParams {
    transcode_service_url_str: String,
    feed_url: Url,
    should_transcode: bool,
}

impl Display for TranscodeParams {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}_{}", &self.transcode_service_url_str, &self.feed_url)
    }
}

#[cfg_attr(not(test),
    io_cached(
    map_error = r##"|e| eyre::Error::new(e)"##,
    type = "AsyncRedisCache<TranscodeParams, String>",
    create = r##" {
        AsyncRedisCache::new("cached_transcodizer=", 600)
            .set_refresh(false)
            .set_connection_string(&conf().get(ConfName::RedisUrl).unwrap())
            .build()
            .await
            .expect("rss_transcodizer cache")
    } "##
))]
async fn cached_transcodize(input: TranscodeParams) -> eyre::Result<String> {
    let transcode_service_url = Url::parse(&input.transcode_service_url_str).unwrap();
    error!("{:?}", input.feed_url);
    let rss_body = (async { reqwest::get(input.feed_url.clone()).await?.bytes().await }).await?;
    let feed = match parser::parse(&rss_body[..]) {
        Ok(x) => {
            debug!("parsed feed");
            x
        },
        Err(e) => {
            return Err(eyre!("could not parse rss, reason: {e}"));
        }
    };

    let mut namespaces = BTreeMap::new();
    namespaces.insert("rss".to_string(), "http://www.itunes.com/dtds/podcast-1.0.dtd".to_string());
    namespaces.insert("itunes".to_string(), "http://www.itunes.com/dtds/podcast-1.0.dtd".to_string());
    let mut feed_builder = rss::ChannelBuilder::default();
    feed_builder.namespaces(namespaces);
    if let Some(x) = feed.title {
        debug!("Title found: {}", x.content);
        feed_builder.title(x.content);
    }

    if let Some(x) = feed.description {
        debug!("Description found: {}", x.content);
        feed_builder.description(x.content);
    }

    if let Some(x) = feed.logo {
        debug!("image found, logo branch: x={:?}", x);
        let mut img_buider = rss::ImageBuilder::default();
        img_buider.url(x.uri);
        img_buider.link(x.title.unwrap_or_default());
        img_buider.description(Some(x.description.unwrap_or_default()));
        feed_builder.image(Some(img_buider.build()));
    } else {
        if let Some(x) = feed.icon {
            debug!("image found, icon branch: x={:?}", x);
            let mut img_buider = rss::ImageBuilder::default();
            img_buider.url(x.uri);
            img_buider.link(x.title.unwrap_or_default());
            img_buider.description(Some(x.description.unwrap_or_default()));
            feed_builder.image(Some(img_buider.build()));
        }
    }

    feed_builder.generator(Some("generated by vod2pod-rss".to_string()));



    let futures = FuturesUnordered::new();
    let service_url_rc = Rc::new(transcode_service_url);
    let feed_url_rc = Rc::new(input.feed_url);
    for entry in feed.entries.iter() {
        let ser_url = service_url_rc.clone();
        let f_url = feed_url_rc.clone();
        futures.push(async move { convert_item(ConvertItemsParams {
            item: entry.to_owned(),
            transcode_service_url: ser_url,
            should_transcode: input.should_transcode,
            feed_url: f_url,
        }).await });
    }

    let item_futures: Vec<_> =  futures.collect().await;
    let mut feed_items: Vec<_> = item_futures.iter().filter_map(|x| if !x.is_none() { Some(x.to_owned().unwrap())} else { None }).collect();
    feed_items.sort_by(|a, b| {
        DateTime::parse_from_rfc2822(b.pub_date().unwrap_or_default()).unwrap_or_default()
            .cmp(
        &DateTime::parse_from_rfc2822(&a.pub_date().unwrap_or_default()).unwrap_or_default()
            )
    });
    feed_builder.items(feed_items);

    let mut itunes_section = ITunesChannelExtensionBuilder::default();
    itunes_section.block(Some("yes".to_string())); //this tells podcast players to not index the podcast in their search engines
    feed_builder.itunes_ext(Some(itunes_section.build()));

    Ok(feed_builder.build().to_string())
}

struct ConvertItemsParams {
    item: Entry,
    transcode_service_url: Rc<Url>,
    should_transcode: bool,
    feed_url: Rc<Url>
}

async fn convert_item(params: ConvertItemsParams) -> Option<Item> {
    let item = params.item;
    let transcode_service_url = params.transcode_service_url;
    let provider = provider::new(&params.feed_url);

    if provider.filter_item(&item).await { return None; }

    let mut item_builder = ItemBuilder::default();
    let mut itunes_builder = ITunesItemExtensionBuilder::default();

    if let Some(x) = &item.title {
        debug!("item title: {}", x.content);
        item_builder.title(Some(x.content.clone()));
    }

    let found_url: Option<Url> = { //FIX: when I stop sucking at rust
        debug!("searching for stream url: {:?}", item.media);
        let mut media_links = Vec::new();
        for x in item.media.iter() {
            let mut found_url: Option<Url> = None;
            for y in x.content.iter() {
                let content_t = y.content_type.clone();
                match content_t.unwrap().to_string() == "audio/mpeg".to_string() {
                    true => {
                        found_url = y.url.clone();
                        break;
                    }
                    false => (),
                }
            }
            if let Some(url) = found_url {
                media_links.push(url);
            }
        }
        let first_link = media_links.first();
        let url: Option<Url> = match first_link {
            Some(x) => Some(x.clone()),
            _ => None,
        };
        debug!("stream url found: {:?}", url);
        url
    };

    let media_url: Url = match found_url {
        Some(x) => {
            debug!("media url found: {:?}", x);
            x
        },
        _ => {

            let url_link = item.links.iter().find(|x| {
                debug!("pondering on link {:?}", x.href.as_str());
                let provider_regexes = provider.media_url_regexes();
                let audio_or_video_regex = regex::Regex::new("^(https?://)?.+\\.(mp3|mp4|wav|avi|mov|flv|wmv|mkv|aac|ogg|webm|3gp|3g2|asf|m4a|mpg|mpeg|ts|m3u|m3u8|pls)$").unwrap();
                return
                    audio_or_video_regex.is_match(x.href.as_str())
                     || provider_regexes.iter().any(|y| y.is_match(x.href.as_str()))
            });

            if let Some(url) = url_link {
                debug!("media url found inside links: {:?}", url_link);
                Url::parse(url.href.to_string().as_str()).unwrap()
            } else {
                warn!("skipping item as no url was found, item: {:?}", item);
                //give-up on item since no url found
                return None;
            }
        }
    };

    let media_element = match item.media.first() {
        Some(x) => x,
        None => {
            warn!("no media element found");
            return None
        }
    };

    let description = get_description(&media_element, &item, &media_url);
    item_builder.description(Some(description));

    if let Some(x) = item.published {
        debug!("Published date found: {:?}", x.to_rfc2822());
        item_builder.pub_date(Some(x.to_rfc2822()));
    }

    if let Some(x) = &media_element.thumbnails.first() {
        debug!("Thumbnail image found: {:?}", x.image.uri);
        itunes_builder.image(Some(x.image.uri.clone()));
    }

    let duration = match media_element.duration {
        Some(x) => {
            debug!("duration found: {} secs", x.as_secs());
            x
        },
        None => {
            debug!("runnign regex on url: {}", media_url.as_str());
            let regexes = provider.media_url_regexes();
            if regexes.iter().any(|x| x.is_match(media_url.as_str())) {
                let duration = match provider.get_item_duration(&media_url).await {
                    Ok(Some(dur)) => Duration::from_secs(dur),
                    Err(e) => {
                        error!("Error getting youtube video duration: {:?}", e);
                        Duration::default()
                    }
                    _ => Duration::default()
                };
                duration
            } else {
                warn!("no duration found");
                Duration::default()
            }
        }
    };

    let duration_secs = duration.as_secs();
    if duration_secs == 0 {
        warn!("skipping episode with 0 duration with title {}", &item.title.map(|t| t.content.to_string()).unwrap_or_default());
        return None;
    }
    let duration_string = format!("{:02}:{:02}:{:02}", duration_secs / 3600, (duration_secs % 3600) / 60, (duration_secs % 60));
    itunes_builder.duration(Some(duration_string));
    let mut transcode_service_url = transcode_service_url.deref().clone();
    let bitrate: u64 = conf().get(ConfName::Mp3Bitrate).unwrap().parse()
        .expect("MP3_BITRATE must be a number");
    let generation_uuid  = uuid::Uuid::new_v4().to_string();
    let codec: AudioCodec = conf().get(ConfName::AudioCodec).unwrap().into();
    let ext = format!(".{}", codec.get_extension_str());
    transcode_service_url
        .query_pairs_mut()
        .append_pair("bitrate", bitrate.to_string().as_str())
        .append_pair("uuid", generation_uuid.as_str())
        .append_pair("duration", duration_secs.to_string().as_str())
        .append_pair("url", media_url.as_str())
        .append_pair("ext", ext.as_str()); //this should allways be last, some players refuse to play urls not ending in .mp3

    let enclosure = Enclosure {
        length: (bitrate * 1024 * duration_secs).to_string(),
        url: transcode_service_url.to_string(),
        mime_type: "audio/mpeg".to_string(),
    };

    debug!("setting enclosure to: \nlength: {}, url: {}, mime_type: {}", enclosure.length, enclosure.url, enclosure.mime_type);

    let guid = generate_guid(&item.id);
    item_builder.guid(Some(guid));
    if params.should_transcode { item_builder.enclosure(Some(enclosure)); }

    item_builder.itunes_ext(Some(itunes_builder.build()));
    debug!("item parsing completed!\n------------------------------\n------------------------------");
    Some(item_builder.build())
}

fn generate_guid(url: &str) -> Guid {
    let digest: md5::Digest = md5::compute(url);
    let md5_bytes_from_digest = digest.0;
    let uuid_for_item: uuid::Builder = uuid::Builder::from_md5_bytes(md5_bytes_from_digest);
    let uuid = uuid_for_item.as_uuid().clone();
    let mut guid_builder = GuidBuilder::default();
    guid_builder.permalink(true).value(uuid.to_string());
    guid_builder.build()
}

fn get_description(media_element: &MediaObject, item: &Entry, url: &Url) -> String {
    const FOOTER: &str = concat!(
        "<br><br>generated by vod2pod-rss ",
        env!("CARGO_PKG_VERSION"),
        " made by Mattia Di Eleuterio (<a href=\"https://github.com/madiele\">madiele</a>). Check out the <a href=\"https://github.com/madiele/vod2pod-rss\">GitHub repository</a>."
    );
    let mut description = "".to_string();

    if let Some(x) = &media_element.description {
        debug!("Description found: {:?}", x.content);
        description = x.content.clone();
    }
    else if let Some(x) = &item.content {
        debug!("Description found: {:?}", x);
        description = x.body.clone().unwrap_or_default();
    }
    else if let Some(x) = &item.summary {
        debug!("Description found: {:?}", x);
        description = x.content.to_string().clone();
    }

    let original_link = format!("<br><br><a href=\"{}\"><p>link to original</p></a>", url);
    return format!("{}{}{}", description, original_link, FOOTER);
}

#[cfg(test)]
mod test {
    use actix_web::{HttpServer, App, web::{self, Data}, HttpResponse, http::header::ContentType, rt, dev::ServerHandle};
    use rss::Channel;
    use test_log::test;

    use super::*;

    async fn validate_must_have_props(rss_transcodizer: RssTranscodizer) -> Result<(), String> {
        println!("fake server up");
        println!("transcodizing");

        let transcodized_rss = rss_transcodizer
            .transcodize()
            .await
            .expect("failed to transcodize RSS feed");

        println!("parsing feed");
        // Parse the transcodized RSS to make it easier to compare
        let transcodized_rss_parsed = Channel::read_from(transcodized_rss.as_bytes()).unwrap();
        println!("checking feed validity");

        _ = match transcodized_rss_parsed.generator() {
            None => return Err(format!("missing generator field")),
            _ => (),
        };

        if transcodized_rss_parsed.items().len() == 0 {
            return Err("no items found".to_string());
        }

        for i in transcodized_rss_parsed.items().iter() {
            let pretty_item = serde_json::to_string(&i).unwrap();

            if i.itunes_ext().is_none() {
                return Err(format!("missing itunes extensions {:?}", pretty_item));
            }

            if i.itunes_ext().unwrap().duration().is_none() {
                return Err(format!("missing duration {:?}", pretty_item));
            }

            if i.guid().is_none() {
                return Err(format!("missing guid for item {:?}", pretty_item));
            }

            if i.enclosure.is_none() {
                return Err(format!("missing enclosure for item {:?}", pretty_item));
            }

            if i.title.is_none() {
                return Err(format!("missing title for item {:?}", pretty_item));
            }

            if i.description.is_none() {
                return Err(format!("missing description for item {:?}", pretty_item));
            }
        }
        return Ok(())
    }

    async fn stop_test(handle: ServerHandle) {
        handle.stop(false).await
    }

    #[test(actix_web::test)]
    async fn rss_podcast_feed() -> Result<(), String> {
        let handle = startup_test("podcast".to_string() , 9872).await;

        let rss_url = Url::parse("http://127.0.0.1:9872/feed.rss").unwrap();
        println!("testing feed {rss_url}");
        let transcode_service_url = "http://127.0.0.1:9872/transcode".parse().unwrap();
        let rss_transcodizer = RssTranscodizer::new(rss_url, transcode_service_url, true);

        let res = validate_must_have_props(rss_transcodizer).await;

        stop_test(handle).await;

        res
    }

    #[test(actix_web::test)]
    async fn rss_twitch_feed() -> Result<(), String> {
        let handle = startup_test("twitch".to_string(), 9871).await;

        let rss_url = Url::parse("http://127.0.0.1:9871/feed.rss").unwrap();
        println!("testing feed {rss_url}");
        let transcode_service_url = "http://127.0.0.1:9871/transcode".parse().unwrap();
        let rss_transcodizer = RssTranscodizer::new(rss_url, transcode_service_url, true);


        let res = validate_must_have_props(rss_transcodizer).await;

        stop_test(handle).await;

        res
    }

    #[test(actix_web::test)]
    async fn rss_youtube_feed() {
        temp_env::async_with_vars([
            ("VALID_URL_DOMAINS", Some("http://127.0.0.1")),
        ], test()).await;

        async fn test() {
            let handle = startup_test("youtube".to_string(), 9870).await;

            let rss_url = Url::parse("http://127.0.0.1:9870/feed.rss").unwrap();
            println!("testing feed {rss_url}");
            let transcode_service_url = "http://127.0.0.1:9870/transcode".parse().unwrap();
            let rss_transcodizer = RssTranscodizer::new(rss_url, transcode_service_url, true);

            let res = validate_must_have_props(rss_transcodizer).await;

            stop_test(handle).await;

            if let Err(e) = res {
                panic!("{e}");
            }
        }
    }

    async fn startup_test(type_test: String, port: u16) -> ServerHandle {
        let feed_type = Data::new(type_test);
        let fake_server = HttpServer::new(move || {
            App::new()
                .app_data(Data::clone(&feed_type))
                .route(
                    "/feed.rss",
                    web::get().to(|feed_type: Data<String>| async move {
                        let url = format!("./src/rss_transcodizer/sample_rss/{}.rss", feed_type.to_string());
                        println!("reading rss from file: {url}");
                        let raw_rss_str = std::fs::read_to_string(url).unwrap();
                        HttpResponse::Ok()
                            .content_type(ContentType::xml())
                            .body(raw_rss_str)
                    }))
                .route("/ready", web::get().to(|| async move {HttpResponse::Ok()}))
        }).bind(("127.0.0.1", port)).unwrap().run();
        let handle = fake_server.handle();
        rt::spawn(fake_server);
        handle
    }
}
